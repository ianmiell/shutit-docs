%
% API Documentation for ShutIt
% Module util
%
% Generated by epydoc 3.0.1
% [Tue Feb 17 12:53:50 2015]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{util \textit{(module)}|(}
\section{Module util}

    \label{util}
ShutIt utility functions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{util:is_file_secure}
    \index{util \textit{(module)}!util.is\_file\_secure \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{is\_file\_secure}(\textit{file\_name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns false if file is considered insecure, true if secure. If file 
    doesn't exist, it's considered secure!

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:colour}
    \index{util \textit{(module)}!util.colour \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{colour}(\textit{code}, \textit{msg})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Colourize the given string for a terminal.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:get_configs}
    \index{util \textit{(module)}!util.get\_configs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_configs}(\textit{shutit}, \textit{configs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Reads config files in, checking their security first (in case 
    passwords/sensitive info is in them).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:issue_warning}
    \index{util \textit{(module)}!util.issue\_warning \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{issue\_warning}(\textit{msg}, \textit{wait})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Issues a warning to stderr.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:get_base_config}
    \index{util \textit{(module)}!util.get\_base\_config \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_base\_config}(\textit{cfg}, \textit{cfg\_parser})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Responsible for getting core configuration from config files.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:parse_args}
    \index{util \textit{(module)}!util.parse\_args \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{parse\_args}(\textit{shutit})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Responsible for parsing arguments.

    TODO: precendence of configs documented

    Environment variables: SHUTIT\_OPTIONS: Loads command line options from
    the environment (if set). Behaves like GREP\_OPTIONS:

    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item space separated list of arguments

      \item backslash before a space escapes the space separation

      \item backslash before a backslash is interpreted as a single backslash

      \item all other backslashes are treated literally

    \end{itemize}

    eg ' a{\textbackslash} b c{\textbackslash} {\textbackslash}d 
    {\textbackslash}{\textbackslash}e' becomes '', 'a b', 'c', 
    '{\textbackslash}d', '{\textbackslash}e' SHUTIT\_OPTIONS is ignored if 
    we are creating a skeleton

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:load_configs}
    \index{util \textit{(module)}!util.load\_configs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{load\_configs}(\textit{shutit})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Responsible for loading config files into ShutIt. Recurses down from 
    configured shutit module paths.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:load_shutit_modules}
    \index{util \textit{(module)}!util.load\_shutit\_modules \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{load\_shutit\_modules}(\textit{shutit})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Responsible for loading the shutit modules based on the configured 
    module paths.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:print_config}
    \index{util \textit{(module)}!util.print\_config \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_config}(\textit{cfg}, \textit{hide\_password}={\tt True}, \textit{history}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a string representing the config of this ShutIt run.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:set_pexpect_child}
    \index{util \textit{(module)}!util.set\_pexpect\_child \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_pexpect\_child}(\textit{key}, \textit{child})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Set a pexpect child in the global dictionary by key.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:get_pexpect_child}
    \index{util \textit{(module)}!util.get\_pexpect\_child \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_pexpect\_child}(\textit{key})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Get a pexpect child in the global dictionary by key.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:load_all_from_path}
    \index{util \textit{(module)}!util.load\_all\_from\_path \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{load\_all\_from\_path}(\textit{shutit}, \textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Dynamically imports files within the same directory (in the end, the 
    path).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:load_mod_from_file}
    \index{util \textit{(module)}!util.load\_mod\_from\_file \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{load\_mod\_from\_file}(\textit{shutit}, \textit{fpath})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Loads modules from a .py file into ShutIt if there are no modules from 
    this file already. We expect to have a callable 'module/0' which 
    returns one or more module objects. If this doesn't exist we assume 
    that the .py file works in the old style (automatically inserting the 
    module into shutit\_global) or it's not a shutit module.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:build_report}
    \index{util \textit{(module)}!util.build\_report \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{build\_report}(\textit{shutit}, \textit{msg}={\tt \texttt{'}\texttt{}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Resposible for constructing a report to be output as part of the build.
    Retrurns report as a string.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:get_commands}
    \index{util \textit{(module)}!util.get\_commands \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_commands}(\textit{shutit})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Gets command that have been run and have not been redacted.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:get_hash}
    \index{util \textit{(module)}!util.get\_hash \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_hash}(\textit{string})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Helper function to get preceding integer eg com.openbet == 1003189494 
    {\textgreater}{\textgreater}{\textgreater} import binascii 
    {\textgreater}{\textgreater}{\textgreater} 
    abs(binascii.crc32('shutit.tk')) 782914092

    Recommended means of determining run order integer part.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:create_skeleton}
    \index{util \textit{(module)}!util.create\_skeleton \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create\_skeleton}(\textit{shutit})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Helper function to create a standard module directory ready to run and 
    tinker with.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:parse_dockerfile}
    \index{util \textit{(module)}!util.parse\_dockerfile \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{parse\_dockerfile}(\textit{shutit}, \textit{contents})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:util_raw_input}
    \index{util \textit{(module)}!util.util\_raw\_input \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{util\_raw\_input}(\textit{shutit}={\tt None}, \textit{prompt}={\tt \texttt{'}\texttt{}\texttt{'}}, \textit{default}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Handles raw\_input calls, and switches off interactivity if there is 
    apparently no controlling terminal (or there are any other problems)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:determine_interactive}
    \index{util \textit{(module)}!util.determine\_interactive \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{determine\_interactive}(\textit{shutit}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determine whether we're in an interactive context. Sets interactivity 
    off if appropriate. cf 
    http://stackoverflow.com/questions/24861351/how-to-detect-if-python-script-is-being-run-as-a-background-process

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:set_noninteractive}
    \index{util \textit{(module)}!util.set\_noninteractive \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_noninteractive}(\textit{shutit}, \textit{msg}={\tt \texttt{'}\texttt{setting non-interactive}\texttt{'}})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:print_stack_trace}
    \index{util \textit{(module)}!util.print\_stack\_trace \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_stack\_trace}()

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:ctrl_c_signal_handler}
    \index{util \textit{(module)}!util.ctrl\_c\_signal\_handler \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ctrl\_c\_signal\_handler}(\textit{signal}, \textit{frame})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    CTRL-c signal handler - enters a pause point if it can.

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{util \textit{(module)}!util.LayerConfigParser \textit{(class)}|(}
\subsection{Class LayerConfigParser}

    \label{util:LayerConfigParser}
\begin{tabular}{cccccc}
% Line for ConfigParser.RawConfigParser, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{ConfigParser.RawConfigParser}\multirow{2}{\BCL}{ConfigParser.RawConfigParser}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{util.LayerConfigParser}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.\_\_init\_\_

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{read}(\textit{self}, \textit{filenames})

\setlength{\parskip}{2ex}
    Read and parse a filename or a list of filenames.

    Files that cannot be opened are silently ignored; this is designed so 
    that you can specify a list of potential configuration file locations 
    (e.g. current directory, user's home directory, systemwide directory), 
    and all existing configuration files in the list will be read.  A 
    single filename may also be given.

    Return list of successfully read files.

\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.read 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{readfp}(\textit{self}, \textit{fp}, \textit{filename}={\tt None})

\setlength{\parskip}{2ex}
    Like read() but the argument must be a file-like object.

    The `fp' argument must have a `readline' method.  Optional second 
    argument is the `filename', which if not given, is taken from fp.name.
    If fp has no `name' attribute, `{\textless}???{\textgreater}' is used.

\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.readfp 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{util:LayerConfigParser:whereset}
    \index{util \textit{(module)}!util.LayerConfigParser \textit{(class)}!util.LayerConfigParser.whereset \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{whereset}(\textit{self}, \textit{section}, \textit{option})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:LayerConfigParser:get_config_set}
    \index{util \textit{(module)}!util.LayerConfigParser \textit{(class)}!util.LayerConfigParser.get\_config\_set \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_config\_set}(\textit{self}, \textit{section}, \textit{option})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a set with each value per config file in it.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{util:LayerConfigParser:reload}
    \index{util \textit{(module)}!util.LayerConfigParser \textit{(class)}!util.LayerConfigParser.reload \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{reload}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Re-reads all layers again. In theory this should overwrite all the old 
    values with any newer ones. It assumes we never delete a config item 
    before reload.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{remove\_section}(\textit{self}, *\textit{args}, **\textit{kwargs})

\setlength{\parskip}{2ex}
    Remove a file section.

\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.remove\_section 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{remove\_option}(\textit{self}, *\textit{args}, **\textit{kwargs})

\setlength{\parskip}{2ex}
    Remove an option.

\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.remove\_option 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set}(\textit{self}, *\textit{args}, **\textit{kwargs})

\setlength{\parskip}{2ex}
    Set an option.

\setlength{\parskip}{1ex}
      Overrides: ConfigParser.RawConfigParser.set 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from ConfigParser.RawConfigParser}}}

\begin{quote}
add\_section(), defaults(), get(), getboolean(), getfloat(), getint(), has\_option(), has\_section(), items(), options(), optionxform(), sections(), write()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from ConfigParser.RawConfigParser}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright OPTCRE, OPTCRE\_NV, SECTCRE}\\
\cline{1-2}
\end{longtable}

    \index{util \textit{(module)}!util.LayerConfigParser \textit{(class)}|)}
    \index{util \textit{(module)}|)}
